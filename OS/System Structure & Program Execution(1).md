# System Structure & Program Execution(1)
<br><br>
### 컴퓨터 시스템 구조

![1](https://user-images.githubusercontent.com/77624879/162800023-42c8af7a-1fb6-49d8-9755-c25bb867e375.jpg)

### 메인 메모리

- CPU의 작업공간이다.
- 프로그램과 데이터를 담고 있는 일시적인 저장장치이다.
- 물리적으로는 DRAM의 집합이며, 논리적으로는 선형의 배열로 구성되어 있다.
- 메모리 컨트롤러 : 메모리를 전담하는 컨트롤러이다.

<br><br>
### CPU

- 매 clock 사이클마다 메모리에서 instruction(기계어)을 하나씩 읽어서 작업을 실행한다.
- Mode bit : 현재 CPU에서 실행되는 것이 운영체제인지 사용자 프로그램인지 구분하는 bit
    - Mode bit에 따라 수행할 수 있는 instruction이 다르다.
- registers : 메모리보다 작은 저장 공간, 메모리보다 빠르다.
- ProgramCounter(PC) : 메인 메모리에서 실행되어야 하는 instruction을 가리킨다.
- interrupt line (Interrupt Request Bit) : 매 instruction 실행이 끝나면, interrupt line을 확인한다. interrupt가 들어온 것이 없으면 다음 instruction을 실행하고, interrupt가 있으면 CPU의 제어권이 자동으로 운영체제에게 넘어간다.
- CPU할당 과정 (interrupt 방식)
    1. 사용자 프로그램(A)에서 I/O가 필요한 코드에 도달하면, 커널모드에 들어가서 CPU를 운영체제에 주게 된다. I/O가 운영체제를 통해서만 접근할 수 있기 때문이다.
    2. 운영체제는 해당 I/O 작업을 디바이스 컨트롤러에게 넘긴다.
    3. CPU가 I/O의 작업을 기다리지 않도록 운영체제는 CPU를 다른 사용자 프로그램(B)에게 넘겨주게 된다.
    4. I/O가 발생하여 데이터가 생기면 디바이스 컨트롤러는 CPU에 인터럽트를 걸게 된다.
    5. CPU는 인터럽트 후 제어권이 운영체제에게 넘어가게 된다.
    6. CPU는 디바이스의 로컬 버퍼에서 데이터를 읽어온 후, 사용자 프로그램(A)의 메모리 공간에 저장한다.
    7. 다시 사용자 프로그램 B에게 CPU를 할당하여 다시 실행시키게 된다.
    8. 프로그램 B가 끝나거나, timer에 의해 차례가 끝나면서 CPU의 할당이 순차적으로 진행되며 프로그램 A의 차례가 되면 A의 메모리 공간에 저장된 값을 갖고와서 실행된다.
    

<br><br>
### Mode bit

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치의 필요성으로 만들어짐
- Mode bit을 통하여 하드웨어적으로 두 가지 모드의 operation 지원
    - 사용자 모드(1) : 사용자 프로그램 수행
    - 모니터 모드(0) : OS 코드 수행 (=커널 모드, 시스템 모드)
    - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 ‘특권 명령’으로 규정
    - Interrupt나 Exception 발생 시, 하드웨어가 mode bit을 0으로 바꿈
    - 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 셋팅
    

<br><br>
### I/O device

- HardDisk도 포함됨(Output Device의 역할 수행)
- 키보드, 마우스, 디스플레이, 디스크 등이 있다.
- 각 I/O 장치는 컨트롤러가 있고, 컨트롤러는 I/O bus와 I/O 장치 사이에 데이터 전송을 위해 존재한다.
- CPU에 비해서 성능이 굉장히 떨어진다.

<br><br>
### BUS

- 컴포넌트 사이에 데이터를 전송한다.
- word 크기의 데이터를 전송한다. 오늘날 대부분의 머신은 4바이트나 8바이트가 word size 이다.

<br><br>
### Device Controller

- I/O 장치를 관리하는 작은 CPU같은 공간이다. →hardware
- 제어 정보를 위한 control registr, status register를 갖는다.
- 각 I/O 장치마다 디바이스 컨트롤러가 있다.
- Local Buffer : 디바이스 컨트롤러의 작업 공간, 일종의 data register
- I/O는 실제 디바이스와 로컬 버퍼 사이에서 일어난다.
- I/O가 끝났을 경우, Device controller가 인터럽트로 CPU에게 그 사실을 알리게 된다.(DMA가 없는 경우)
- Device driver(장치 구동기)
    - OS코드 중 각 장치별 처리 루틴 → software
    - OS는 device driver를 통해 I/O device에 접근한다.

<br><br>
### 타이머

- 특정 프로그램이 무한루프등을 통해 CPU를 독점하는 것을 막기 위한 것이다. → CPU의 타임쉐어링을 위해 타이머가 있다.
- 타이머는 매 clock마다 1씩 감소하게 된다.
- 타이머 값이 0이 되면 타이머 인터럽트가 발생한다.
- 타이머는  time sharing을 구현하기 위해 널리 사용된다.
- 타이머는 현재 시간을 계산하기 위해서도 사용된다.
- 운영체제가 사용자 프로그램에게 CPU 제어권을 줄 때
    1. 타이머에 값을 세팅
    2. 사용자 프로그램에 CPU를 할당
    3. 세팅된 시간이 지나면, 타이머가 CPU에 인터럽트를 걸게 된다.
    4. 이후, 커널 모드에 들어가게 되고 운영체제는 다음 프로그램을 정한 후, 그 프로그램에게 CPU를 넘겨주게 된다.

<br><br>
### DMA Controller

- 직접 메모리에 접근할 수 있는 컨트롤러
- 원래 메모리는 CPU만 접근할 수 있다. 그러나, CPU에 과다한 Interrupt가 쏠리기 때문에 비효율적이게 됨. 따라서 I/O장치에서 들어오는 Interrupt를 DMA에서 받고, I/O장치가 갖고 있는 local buffer에서 데이터를 가져와 메인 메모리에 저장함.
- I/O 장치에서 발생한 Interrupt를 처리한 후, CPU에 Interrupt를 한번 걸어서 메모리에 값이 올라 갔음을 알림.
- 즉, CPU에 과다하게 걸리는 Interrupt의 빈도수를 줄이기 위함.
- Memory Controller는 CPU와 DMA Controller가 둘 다 메모리에 접근할 수 있기 때문에 둘이 동시에 메모리에 접근하는 것을 중재해주는 역할을 수행함

<br><br>
### 입출력(I/O)의 수행

- 모든 입출력 명령은 특권 명령
- 사용자 프로그램은 어떻게 I/O를 하는가?
    - 시스템 콜(System call)
    
    *System call : 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것
    
    - trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
    - 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
    - 올바른 I/O요청인지 확인 후 I/O 수행
    - I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김
    

<br><br>
### 인터럽트(Interrupt)

- 보통 인터럽트는 하드웨어가 발생시킨 인터럽트를 말함
- 현대의 운영체제는 인터럽트에 의해 구동됨
- 인터럽트 당한 시점의 레지스터와 program counter를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
- 넓은의미의 인터럽트
    - Interrupt(하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트(I/O, timer 등)
    - Trap(소프트웨어 인터럽트) : 소프트웨어가 발생시킨 인터럽트(Exception, System call)
    
    *Exception : 프로그램이 오류를 범한 경우
    
- 관련 용어
    - 인터럽트 벡터 : 해당 인터럽트의 처리 루틴 주소를 가지고 있음
    - 인터럽트 처리루틴(인터럽트 핸들러) : 해당 인터럽트를 처리하는 커널 함수
