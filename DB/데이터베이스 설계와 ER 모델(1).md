# 데이터베이스 설계와 ER 모델(1)

### 강한 엔티티 타입

- 정규 엔티티 타입
- 독자적으로 존재하며 엔티티 타입 내에서 자신의 키 애트리뷰트를 사용하여 고유하게 엔티티들을 식별할 수 있는 엔티티 타입

### 약한 엔티티 타입

- 키를 형성하기에 충분한 애트리뷰트들을 갖지 못한 엔티티 타입
- 소유 엔티티 타입이 있어야 존재가능함
- 소유 엔티티 타입의 키 애트리뷰트를 결합해야만 고유하게 약한 엔티티 타입의 엔티티들을 식별할 수 있음

**소유 엔티티타입: 약한 엔티티 타입과 연관된 강한 엔티티 타입* 

### 애트리뷰트

- 하나의 엔티티는 연관된 애트리뷰트들의 집합으로 설명됨
    - EX) 사원 Entity 는 ‘사원번호’, ‘이름’, ‘직책’, ‘급여’ 등의 애트리뷰트를 가짐
- 한 애트리뷰트의 도메인은 그 애트리뷰트가 가질 수 있는 모든 가능한 값들의 집합을 의미
    - EX) 사원번호는 1000-9999까지의 값을 가짐
- 여러 애트리뷰트가 동일한 도메인을 공유할 수 있음
    - EX) 사원번호와 부서번호가 네 자리 정수를 가질 수 있음
- 키 애트리뷰트는 한 애트리뷰트 또는 애트리뷰트들의 모임으로서 한 엔티티 타입 내에서 각 엔티티를 고유하게 식별함
- **ER 다이어그램**에서 **기본 키**에 속하는 애트리뷰트는 밑줄을 그어 표시함
- **요구사항 명세서**에 **명사**나 **형용사**로 표현됨
- 엔티티는 독립적인 의미를 갖는데 반해서 애트리뷰트는 독립적인 의미를 갖지 않음
- **ER 다이어그램**에서 **타원형**으로 나타냄
- **애트리뷰트**와 **엔티티 타입**은 **실선**으로 연결

### 단순 애트리뷰트(simple attribute)

- 더 이상 **다른 애트리뷰트로 나눌 수 없는 애트리뷰트**
- ER 다이어그램에서 실선 타원으로 표현함
- ER 다이어그램에서 대부분의 애트리뷰트는 단순 애트리뷰트

![1](https://user-images.githubusercontent.com/77624879/163001234-59793382-dc8d-42ea-b222-54cf63932a0f.jpg)

### 복합 애트리뷰트(composite attribute)

- *두 개 이상의 애트리뷰트로 이루어진 애트리뷰트 (EX. Address)*
- 동일한 엔티티 타입이나 관계에 속하는 애트리뷰트들 중에서 밀접하게 연관된 것을 모아놓은 것
- 요즘은 이런 방식보다 전부 따로 분해해서 정교하게 사용함

![2](https://user-images.githubusercontent.com/77624879/163001294-5e43b0d3-1338-4f4d-95c6-eaa5d96140d3.jpg)
### 단일 값 애트리뷰트(single-valued attribute)

- 각 엔티티마다 정확하게 하나의 값을 갖는 애트리뷰트
- **ER 다이어그램**에서 **단순 애트리뷰트와 동일**하게 표현됨
    - Ex. 사원의 사원번호 애트리뷰트는 어떤 사원도 두 개 이상의 사원번호를 갖지 않으므로 단일 값 애트리뷰트
- ER 다이어그램에서 대부분의 애트리뷰트는 단일 값 애트리뷰트

### 다치 애트리뷰트(multi-valued attribute)

- 각 에티티마다 여러개의 값을 가질 수 있는 애트리뷰트
- 관계 데이터 모델에서 표현 불가
- **ER 다이어그램**에서 **이중선 타원**으로 표현함

![3](https://user-images.githubusercontent.com/77624879/163001320-31b8da62-c240-4640-ada9-d69c6b412542.jpg)
### 저장된 애트리뷰트(stored attribute)

- 다른 애트리뷰트와 독립적으로 존재하는 애트리뷰트
- **ER 다이어그램**에서 **단순 애트리뷰트와 동일**하게 표현됨
- ER 다이어그램에서 대부분의 애트리뷰트는 저장된 애트리뷰트
    - EX) 사원 엔티티 타입에서 ‘사원이름’, ‘급여’는 다른 애트리뷰트와 독립적으로 존재

### 유도된 애트리뷰트(derived attribute)

- 저장된 애트리뷰트와 반대의 개념
- 다른 애트리뷰트의 값으로부터 얻어진 애트리뷰트
    - EX) 나이 애트리뷰트는 생년월일 애트리뷰트를 통해 알 수 있음
- 관계 데이터베이스에서 릴레이션의 애트리뷰트로 포함시키지 않는 것이 좋음
- **ER 다이어그램**에서 **점선 타원**으로 표현됨

![4](https://user-images.githubusercontent.com/77624879/163001327-17439019-5fd8-4e3c-b595-ef20511f7d00.jpg)
### 약한 엔티티 타입

- 키를 형성하기에 충분한 애트리뷰트들을 갖지 못한 엔티티 타입
- 약한 엔티티 타입에게 키 애트리뷰트를 제공하는 엔티티 타입을 소유 엔티티 타입(owner entity type) 또는 식별 엔티티 타입(identifying entity type)라고 부름
- **ER 다이어그램**에서 **이중선 직사각형**으로 표기
- 약한 엔티티 타입의 **부분 키는 점선 밑줄**을 그어 표시

![5](https://user-images.githubusercontent.com/77624879/163001336-08925a2a-900f-4e62-bcfd-9e85df5226f2.png)
### 부분 키(partial key)

- 약한 엔티티 타입에서 개별 객체를 구분하는 속성
- 독립적인 키로는 존재할 수 없지만 상위 개체 타입의 키와 결합하여 약한 개체타입의 개별 개체를 고유하게 식별하는 속성을 식별자(Discriminator) 혹은 부분키(Partial Key)라고 한다.
    - EX. 가족과 직원이라는 두 개의 개체가 부양이라는 관계를 맺고 있는 경우
    - 직원에는 직원번호, 이름, 직책이라는 속성들이 있고 직원번호가 직원의 고유키
    - 직원이 부양하는 가족이 있다고 할 때 직원이 없으면 부양가족도 존재할 수 없으므로 가족은 약한개체가 됨.
    - 또한 부양가족의 이름이라는 속성은 직원의 직원번호와 결합하여 약한 개체 타입을 식별할 수 있으므로 부분키(식별자)가 됨.
    
    <img width="230" alt="6" src="https://user-images.githubusercontent.com/77624879/163001344-061cf264-78ee-45e5-9231-4993e3b7b93f.png">

### 관계와 관계 타입

- 관계는 엔티티들 사이에 존재하는 연관이나 연결로서 두 개 이상의 엔티티 타입들 사이의 맵핑시켜주는 것으로 생각할 수 있음
- 관계 집합은 동질의 관계들의 집합
- 관계 타입은 동질의 관계들의 틀
- 관계 집합과 관계 **타입을 엄격하게 구분할 필요는 없음**
- **요구사항 명세**에서 흔히 **동사**는 ER 다이어그램에서 관계로 표현됨
- **ER 다이어그램**에서 **다이아몬드**로 표기
- 관계 타입이 서로 **연관시키는 엔티티 타입들을 관계 타입**에 **실선으로 연결**함

![7](https://user-images.githubusercontent.com/77624879/163001398-fe8ef5ca-ca6d-4885-bdb7-4be4586a24c2.jpg)
### 관계의 애트리뷰트

- 관계 타입은 관계의 특징을 기술하는 애트리뷰트들을 가질 수 있음
- 관계 타입은 키 애트리뷰트를 갖지 않음 → **아무 의미가 없기 때문**
    - 관계가 관리하는 엔티티의 키들이 모여 관계 애트리뷰트의 키 역할을 함

![8](https://user-images.githubusercontent.com/77624879/163001417-4994485d-24be-4c45-ab6d-30d371959829.png)

### 차수(degree)

- 관계로 연결된 엔티티 타입들의 개수를 의미
- 실세계에서 가장 흔한 관계는 두 개의 엔티티 타입을 연결하는 2진 관계

![9](https://user-images.githubusercontent.com/77624879/163001424-32a8feb4-7ec2-4fbe-8ed4-8bf705fe91fb.png)

### 카디날리티

- 카디날리티 비율은 한 엔티티가 참여할 수 있는 관계의 수를 나타냄
- 엔티티는 관계를 맺지 않을 수도 있음
- 관계 타입에 참여하는 엔티티들의 가능한 조합을 재현함
- 관계를 흔히 1:1, 1:N, M:N으로 구분
- 카디날리티에 관한 **정보**는 **간선 위에 나타냄**
- 카디날리티는 관계 데이터 모델로 만드는 데에 있어 중요한 정보임
    - 관계데이터 모델은 원자값만을 갖기 때문에 1:N, M:N의 관계에서는 집합 처리가 필요
    - 스키마의 설계가 달라짐

![10](https://user-images.githubusercontent.com/77624879/163001433-9126ade9-8430-4b06-be60-0e64ad497c0b.png)

### 1:1 관계

- E1의 각 엔티티가 정확하게 E2의 한 엔티티와 연관되고, E2의 각 엔티티가 정확하게 E1의 한 엔티티와 연관되면 이 관계를 1:1 관계라고 함
- Ex. 각 사원에 대해 최대한 한 개의 PC가 있고, 각 PC에 대해 최대한 한 명의 사원이 있으면 사원과 PC의 관계는 1:1 관계이다

### 1:N 관계

- 실세계에서 가장 흔히 나타나는 관계
- E1의 각 엔티티가 E2의 임의의 개수의 엔티티와 연관되고, E2의 각 엔티티는 정확하게 E1의 한 엔티티와 연관되면 이 관계를 1:N 관계라고 함
- Ex. 각 사원에 대해 최대한 한 대의 PC가 있고, 각 PC에 대해 여러 명의 사원들이 있으면 PC와 사원 간의 관계는 1:N 관계이다

### M:N 관계

- 한 엔티티 타입에 속하는 임의의 개수의 엔티티가 다른 엔티티 타입에 속하는 임의의 개수의 엔티티와 연관됨
- Ex. 각 사원에 대해 여러 대의 PC가 있고, 각 PC에 대해 여러 명의 사원들이 있으면 사원과 PC의 관계는 M:N 관계이다.

### 카디날리티 비율의 최소값과 최대값

- **ER 다이어그램**에서 관계 타입과 엔티티 타입을 **실선 위에 (min, max) 형태**로 표기
- min은 이 엔티티 타입 내의 각 엔티티는 적어도 min 번 관계에 참여함을 의미
- max는 이 엔티티 타입 내의 각 엔티티는 최대한 max 번 관계에 참여함을 의미
- **min=0 은 어떤 엔티티가 반드시 관계에 참여해야 할 필요가 없음**을 의미
- **max=* 은 어떤 엔티티가 관계에 임의의 수만큼 참여할 수 있음**을 의미

![11](https://user-images.githubusercontent.com/77624879/163001446-43a3b0b5-3821-4ce2-bed9-699a8a05b633.png)

### 역할(role)

- 관계 타입의 의미를 명확하게 하기 위해 사용됨
- 특히 하나의 관계 타입에 하나의 엔티티 타입이 여러 번 나타나는 경우에는 반드시 역할을 표기해야 함
- **관계 타입의 간선 위에 표시**

![12](https://user-images.githubusercontent.com/77624879/163001453-3ea5e39d-2ea5-4e2d-a7c9-ebce4c7c3e0d.png)

### 전체 참여와 부분 참여

- 전체 참여는 어떤 관계에 엔티티 타입 E1의 모든 엔티티들이 관계 타입 R에 의해서 어떤 엔티티 타입 E2의 어떤 엔티티와 연관되는 것을 의미
- 부분 참여는 어떤 관계에 엔티티 타입 E1의 일부 엔티티만 참여하는 것을 의미
- 약한 엔티티 타입은 항상 관계에 전체 참여
- 전체 참여는 **ER 다이어 그램**에서 **이중 실선**으로 표시
- 카디날리티 비율과 함께 **참여 제약조건은 관계에 대한 중요한 제약조건**임

  <img width="384" alt="13" src="https://user-images.githubusercontent.com/77624879/163001463-52a3d2c6-dbb8-4e6a-9c06-aa137516529c.png">
<br>

### 다중 관계

- 두 엔티티 타입 사이에 두 개 이상의 관계 타입이 존재할 수 있음

![14](https://user-images.githubusercontent.com/77624879/163001474-54232e4b-3dd5-472a-8a96-fd11a9554320.png)

### 순환적 관계

- 하나의 엔티티 타입이 동일한 관계 타입에 두 번 이상 참여하는 것

![15](https://user-images.githubusercontent.com/77624879/163001483-1d863f49-c8ba-4a34-83ef-800aa88e9982.png)

### ER 스키마를 작성하기 위한 지침

- 엔티티는 키 애트리뷰트 이외에 설명 정보를 추가로 가짐
- 다치 애트리뷰트는 앤티티로 분류해야 함
- 애트리뷰트들이 직접적으로 설명하는 엔티티에 애트리뷰트들을 붙임
- 가능한 한 복합 식별자를 피함
- 관계는 일반적으로 독자적으로 존재할 수 없지만 엔티티 타입과 관계 타입을 절대적으로 구분하는 것은 어려움
    - 설계자의 선택에 따라 달라질 수 있음

![16](https://user-images.githubusercontent.com/77624879/163001503-fad4d143-2b7a-4559-bc63-70a5c1e84a92.jpg)

### 데이터베이스 설계 과정

- 응용의 요구사항을 수집하여 기술
- 응용과 연관이 있는 엔티티 타입들을 식별
- 응용과 연관이 있는 관계 타입들을 식별
- 관계가 1:1, 1:N, M:N 중에서 어느 것에 해당하는지 결정
- 엔티티 타입과 관계 타입들에 필요한 애트리뷰트들을 식별하고, 각 애트리뷰트가 가질 수 있는 값들의 집합을 식별
- 엔티티 타입들을 위한 기본 키를 식별
- 응용을 위한 ER 스키마 다이어그램을 그림
- ER 스키마 다이어그램이 응용에 대한 요구사항과 부합되는지 검사
- ER 스키마 다이어그램을 DBMS에서 사용되는 데이터베이스 모델로 변환
