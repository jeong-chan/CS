# 트랜잭션

### **트랜잭션**(transaction)

- 항공기 예약, 은행, 신용 카드 처리, 대형 할인점 등에서는 대규모 데이터베이스를 수백, 수천 명 이상의 사용자들이 동시에 접근함
- 많은 사용자들이 동시에 데이터베이스의 서로 다른 부분 또는 동일한 부분을 접근하면서 데이터베이스를 사용함
- **동시성 제어**(concurrency control)
    - 동시에 수행되는 트랜잭션들이 데이터베이스에 미치는 영향은 이들을 순차적으로 수행하였을 때 데이터베이스에 미치는 영향과 같도록 보장
    - 다수 사용자가 데이터베이스를 동시에 접근하도록 허용하면서 데이터베이스의 일관성을 유지함
- **회복**(recovery)
    - 데이터베이스를 갱신하는 도중에 시스템이 고장 나도 데이터베이스의 일관성을 유지함

### 데이터베이스 시스템 환경에서 흔히 볼 수 있는 몇 가지 응용의 예

```sql
사원이 500명이고 모든 사원의 급여를 6% 인상하는 연산을 릴레이션에서 수행함
UPDATE EMPLOYEE
SET SALARY = SALARY * 1.06;
```

- 500명 전원의 급여가 수정되거나 한 명의 급여도 갱신되지 않도록 DBMS가 보장해야 함
- DBMS가 추가로 정보를 유지하지 않는다면 DMBS가 재기동된 후에 어느 직원의 튜플까지 수정되었는가를 알 수 없음. 따라서 **로그**(log) 유지

```sql
정미림씨가 자신의 계좌에서 100000원을 안명석씨의 계좌로 보내는 상황
UPDATE CUSTOMER
SET BALANCE = BALANCE - 100000
WHERE CUST_NAME = '정미림';

UPDATE CUSTOMER
SET BALANCE = BALANCE + 100000
WHERE CUST_NAME = '안명석';
```

- 두 개의 UPDATE문을 사용하여 각각 잔액을 조정함
- 위의 두 개의 UPDATE문은 둘 다 완전하게 수행되거나 한 UPDATE 문도 수행되지 않도록 하나의 트랜잭션(단위)처럼 DBMS가 보장해야 함
- 기본적으로 각각의 SQL문이 하나의 트랜잭션으로 취급됨
- 두 개 이상의 SQL문들을 하나의 트랜잭션으로 취급하려면 사용자가 이를 명시적으로 표시해야 함

- 이 외에 비행기 등을 예약 할 때, 중복 좌석이 발생하지 않도록 보장해야 하는 경우가 있음

### 트랜잭션의 특성(**ACID** 특성)

- 원자성(**A**tomicity)
    - 한 트랜잭션 내의 모든 연산들이 완전히 수행되거나 전혀 수행되지 않음(all or nothing)을 의미
    - DBMS의 회복 모듈은 시스템이 다운되는 경우에, 부분적으로 데이터베이스를 갱신한 트랜잭션의 영향을 취소함으로써 트랜잭션의 원자성을 보장함
    - 완료된 트랜잭션이 갱신한 사항은 트랜잭션의 영향을 재수행함으로써 트랜잭션의 원자성을 보장함
- 일관성(**C**onsistency)
    - 어떤 트랜잭션이 수행되기 전에 데이터베이스가 일관된 상태를 가졌다면 트랜잭션이 수행된 후에 데이터베이스는 또 다른 일관된 상태를 가짐
    - 트랜잭션이 수행되는 도중에는 데이터베이스가 일시적으로 일관된 상태를 갖지 않을 수 있음
    
    ![9](https://user-images.githubusercontent.com/77624879/164511353-503dd686-2746-4cfc-b4a2-7ddace0ce809.png)
    
- 고립성(**I**solation)
    - 한 트랜잭션이 데이터를 갱신하는 동안 이 트랜잭션이 완료되기 전에는 갱신 중인 데이터를 다른 트랜잭션들이 접근하지 못하도록 해야 함
    - 다수의 트랜잭션들이 동시에 수행되더라도 그 결과는 어떤 순서에 따라 트랜잭션들을 하나씩 차례대로 수행한 결과와 같아야 함
    - DBMS의 동시성 제어 모듈이 트랜잭션의 고립성을 보장함
    - DMBS는 응용 프로그램들의 요구사항에 따라 다양한 **고립 수준**(isolation level)을 제공함
- 지속성(**D**urability)
    - 일단 한 트랜잭션이 완료되면 이 트랜잭션이 갱신한 것은 그 후에 시스템에 고장이 발생하더라도 손실되지 않음
    - 완료된 트랜잭션의 효과는 시스템이 고장난 경우에도 데이터베이스에 반영됨
    - DMBS의 회복 모듈은 시스템이 다운되는 경우에도 트랜잭션의 지속성을 보장함

![10](https://user-images.githubusercontent.com/77624879/164511355-12d0ffa3-d388-474e-9e3e-54ab7edea8ef.png)

### 트랜잭션의 **완료**(commit)

- 트랜잭션에서 변경하려는 내용이 데이터베이스에 완전하게 반영됨
- SQL 구문상으로 COMMIT WORK

### 트랜잭션의 **철회**(abort)

- 트랜잭션에서 변경하려는 내용이 데이터베이스에 일부만 반영된 경우에는 원자성을 보장하기 위해서, 트랜잭션이 갱신한 사항을 트랜잭션이 수행되기 전의 상태로 되돌림
- SQL 구문상으로 ROLLBACK WORK

### commit과 rollback

![11](https://user-images.githubusercontent.com/77624879/164511356-b447eed7-6ff7-4c25-b45e-d3c55ef6c9ca.jpg)

![12](https://user-images.githubusercontent.com/77624879/164511358-0fac5ccb-491c-4415-b015-882238c6b6f5.png)

### 트랜잭션이 성공하지 못하는 원인

- 시스템(사이트) 고장
    - 중앙 처리 장치, 주기억 장치, 전원 공급 장치 등이 고장남
- 트랜잭션 고장
    - 트랜잭션 고장은 트랜잭션이 수행되는 도중에 철회됨
- 매체 고장
    - 디스크 헤드, 디스크 콘트롤러 등이 고장 나서 보조 기억 장치의 전부 또는 일부 내용이 지워짐
- 통신 고장
- 자연적 재해
- 부주의 또는 고의적인 고장

### 동시성 제어

- 대부분의 DBMS들은 다수 사용자용
- 여러 사용자들이 동시에 동일한 테이블을 접근하기도 함
- DBMS의 성능을 높이기 위해 여러 사용자의 질의나 프로그램들을 동시에 수행하는 것이 필수적
- 동시성 제어 기법은 여러 사용자들이 다수의 트랜잭션들을 동시에 수행하는 환경에서 부정확한 결과를 생성할 수 있는, 트랜잭션들 간의 간섭이 생기지 않도록 함

![13](https://user-images.githubusercontent.com/77624879/164511359-1f65c958-922f-4d4c-85ed-95e2f40d2279.jpg)

### **직렬 스케줄**(serial schedule)

- 여러 트랜잭션들의 집합을 한 번에 한 트랜잭션씩 차례대로 수행함

### **비 직렬 스케줄**(non-serial schedule)

- 여러 트랜잭션들을 동시에 수행함

### **직렬 가능**(serializable)

- 비 직렬 스케줄의 결과가 어떤 직렬 스케줄의 수행 결과와 동등함
- 개발자들이 원하는 스케줄 방법

### 데이터베이스 연산

- **Input(X)**
    - 데이터베이스 항목 X를 포함하고 있는 블록을 주기억장치의 버퍼로 읽어들임
- **Output(X)**
    - 데이터베이스 항목 X를 포함하고 있는 블록을 디스크에 기록함
- **read_item(X)**
    - 주기억 장치 버퍼에서 데이터베이스 항목 X의 값을 프로그램 변수 X로 복사함
- **write_item(X)**
    - 프로그램 변수 X의 값을 주기억 장치 내의 데이터베이스 항목 X에 기록함

![14](https://user-images.githubusercontent.com/77624879/164511362-f7eaeaae-841e-496e-8bac-8b6802c4b8ba.png)

### 동시성 제어를 하지 않고 다수의 트랜잭션을 동시에 수행할 때 생길 수 있는 문제

- **갱신 손실**(lost update)
    - 수행 중인 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어 씀으로써 갱신이 무효가 되는 것

![15](https://user-images.githubusercontent.com/77624879/164511364-e116b6c0-f0cd-40c1-9fe4-d55e0dcc503c.png)

- **오손 데이터 읽기**(dirty read)
    - 완료되지 않은 트랜잭션이 갱신한 데이터를 읽는 것

![16](https://user-images.githubusercontent.com/77624879/164511365-5e71e465-0023-4aed-9924-5582882a0e1a.png)

- **반복할 수 없는 읽기**(unrepeatable read)
    - 한 트랜잭션이 동일한 데이터를 두 번 읽을 때 서로 다른 값을 읽는 것

![17](https://user-images.githubusercontent.com/77624879/164511366-6334e558-679f-43fb-9263-e23a428a17cb.png)

